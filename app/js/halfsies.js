// Generated by CoffeeScript 1.6.2
(function() {
  var services,
    __slice = [].slice;

  services = angular.module('halfsies', []);

  services.factory('deepCopyJSON', function() {
    return function(obj) {
      return JSON.parse(JSON.stringify(obj));
    };
  });

  services.factory('protect', function() {
    return function(fn) {
      return function() {
        var argCopies;

        argCopies = _(arguments).map(function(arg) {
          return deepCopyJSON(arg);
        });
        return fn.apply({}, argCopies);
      };
    };
  });

  services.factory('newRegex', function() {
    return function() {
      var arg, args, regex, _i, _len;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      regex = "";
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        if (arg instanceof RegExp) {
          regex += arg.toString().slice(1, -1);
        } else {
          regex += arg;
        }
      }
      return new RegExp(regex);
    };
  });

  services.factory('matcher', function() {
    return function(string, regex) {
      var buffer, match;

      buffer = [];
      match = string.match(regex);
      if (match) {
        return {
          before: string.slice(0, match.index),
          match: string.slice(match.index, +(match.index + match[0].length - 1) + 1 || 9e9),
          after: string.slice(match.index + match[0].length) || ""
        };
      } else {
        return false;
      }
    };
  });

  services.factory("matchAll", [
    'matcher', function(matcher) {
      return function(string, regex) {
        var after, before, buffer, match, _ref;

        buffer = [];
        while (matcher(string, regex)) {
          _ref = matcher(string, regex), before = _ref.before, match = _ref.match, after = _ref.after;
          buffer = buffer.concat([
            {
              contents: before
            }, {
              match: true,
              contents: match
            }
          ]);
          string = after;
        }
        buffer.push({
          type: 'rest',
          contents: string
        });
        return buffer;
      };
    }
  ]);

  services.factory('parseNextTag', [
    'matcher', 'parseQuotes', function(matcher, parseQuotes) {
      return function(string) {
        var after, afterTag, before, beforeTag, i, match, tag, token, tokens, _i, _len, _ref, _ref1;

        if (!(_ref = matcher(string, /\</), before = _ref.before, match = _ref.match, after = _ref.after, _ref)) {
          return false;
        }
        beforeTag = before;
        tag = match;
        afterTag = "";
        tokens = parseQuotes(after);
        for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
          token = tokens[i];
          if (token.type === 'text' && token.contents.match(/\>/)) {
            _ref1 = matcher(token.contents, /\>/), match = _ref1.match, before = _ref1.before, after = _ref1.after;
            tag += before + match;
            afterTag += after;
            break;
          } else {
            tag += token.contents;
          }
        }
        afterTag += _(tokens.slice(i + 1)).pluck('contents').join('');
        return {
          before: beforeTag,
          tag: tag,
          after: afterTag
        };
      };
    }
  ]);

  services.factory('parseTags', [
    'parseNextTag', function(parseNextTag) {
      var parseTags;

      parseTags = function(text) {
        var after, before, tag, _ref;

        if (_ref = parseNextTag(text), before = _ref.before, after = _ref.after, tag = _ref.tag, _ref) {
          return [
            {
              type: 'text',
              contents: before
            }, {
              type: 'tag',
              contents: tag
            }
          ].concat(parseTags(after));
        } else {
          return [
            {
              type: 'text',
              contents: text
            }
          ];
        }
      };
      return function(text) {
        return parseTags(text);
      };
    }
  ]);

  services.factory('parseNextQuote', [
    'matcher', function(matcher) {
      return function(string) {
        var after, before, match, matchChar, textBeforeQuote, _ref, _ref1;

        _ref = matcher(string, /"|'/), before = _ref.before, match = _ref.match, after = _ref.after;
        matchChar = match;
        textBeforeQuote = before;
        if (match) {
          _ref1 = matcher(after, new RegExp(match)), before = _ref1.before, after = _ref1.after;
          return {
            quote: matchChar + before + matchChar,
            before: textBeforeQuote,
            after: after
          };
        } else {
          return false;
        }
      };
    }
  ]);

  services.factory('parseQuotes', [
    'parseNextQuote', function(parseNextQuote) {
      var parseQuotes;

      parseQuotes = function(string) {
        var after, before, quote, _ref;

        _ref = parseNextQuote(string), before = _ref.before, quote = _ref.quote, after = _ref.after;
        if (!before) {
          return [
            {
              type: 'text',
              contents: string
            }
          ];
        } else {
          return [
            {
              type: 'text',
              contents: before
            }, {
              type: 'quote',
              contents: quote
            }
          ].concat(parseQuotes(after));
        }
      };
      return function(string) {
        return parseQuotes(string);
      };
    }
  ]);

  services.factory('isCloseTag', function() {
    return function(tagString) {
      return tagString.match(/^\<\//) !== null;
    };
  });

  services.factory("tagContents", [
    'isCloseTag', function(isCloseTag) {
      return function(tagString) {
        if (isCloseTag(tagString)) {
          return tagString.slice(2, +(tagString.length - 2) + 1 || 9e9);
        } else {
          return tagString.slice(1, +(tagString.length - 2) + 1 || 9e9);
        }
      };
    }
  ]);

  services.factory("tagType", [
    'tagContents', function(tagContents) {
      return function(tagString) {
        var contents;

        contents = tagContents(tagString);
        return contents.split(" ")[0];
      };
    }
  ]);

  services.factory('processTags', [
    'tagType', 'isCloseTag', function(tagType, isCloseTag) {
      return function(tokens) {
        var token, _i, _len;

        for (_i = 0, _len = tokens.length; _i < _len; _i++) {
          token = tokens[_i];
          if (token.type === 'tag') {
            token.tag = tagType(token.contents);
            if (isCloseTag(token.contents)) {
              token.close = true;
            }
          }
        }
        return tokens;
      };
    }
  ]);

  services.factory("insertNewlines", [
    'matchAll', function(matchAll) {
      return function(tokens) {
        var res;

        res = _.map(tokens, function(token) {
          var newTokens;

          if (token.type === 'text') {
            newTokens = matchAll(token.contents, /\n/);
            return _.map(newTokens, function(newToken) {
              if (newToken.match) {
                return {
                  type: 'newline',
                  contents: '\n'
                };
              } else {
                return {
                  type: 'text',
                  contents: newToken.contents
                };
              }
            });
          } else {
            return token;
          }
        });
        return _.flatten(res);
      };
    }
  ]);

  services.factory("groupByLines", [
    'deepCopyJSON', function(deepCopyJSON) {
      return function(tokens) {
        var currentLine, lines, token;

        tokens = deepCopyJSON(tokens);
        lines = [];
        currentLine = [];
        while (token = tokens.shift()) {
          if (token.type === 'newline') {
            lines.push(currentLine);
            currentLine = [];
          } else {
            currentLine.push(token);
          }
        }
        lines.push(currentLine);
        return lines;
      };
    }
  ]);

  services.factory('spacesToIndent', function() {
    return function(num) {
      return parseInt(num / 2);
    };
  });

  services.factory('indents', [
    'spacesToIndent', function(spacesToIndent) {
      return function(text) {
        var numSpaces;

        numSpaces = text.match(/^ */)[0].length;
        return spacesToIndent(numSpaces);
      };
    }
  ]);

  services.factory('indentLine', [
    'deepCopyJSON', 'indents', function(deepCopy, indents) {
      return function(line) {
        var firstToken;

        firstToken = line[0];
        if (firstToken.type !== 'text') {
          line.indent = 0;
        } else {
          line.indent = indents(firstToken.contents);
          firstToken.contents = _.string.lstrip(firstToken.contents);
        }
        return line;
      };
    }
  ]);

  services.factory("indentLines", [
    'indentLines', function(line) {
      return function(lines) {
        return lines.map(line(indentLine(line)));
      };
    }
  ]);

  /*
  #   groupByIndent tranform lines with indent and token properties
  #   into nodes with children. Each node has properties:
  #   line: the nodes line
  #   children: the nodes children
  */


  services.factory('groupByIndent', [
    'deepCopyJSON', function(deepCopyJSON) {
      var transform;

      transform = function(lines, level, current) {
        var line;

        if (!current.children) {
          current.children = [];
        }
        while (lines[0]) {
          if (lines[0].indent === level) {
            line = lines.shift();
            line.children = [];
            current.children.push(line);
          } else if (lines[0].indent > level) {
            transform(lines, lines[0].indent, line);
          } else {
            return;
          }
        }
        return current;
      };
      transform = function(rest, level) {
        var copy, current, line, nested, res;

        copy = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = rest.length; _i < _len; _i++) {
            line = rest[_i];
            _results.push(line);
          }
          return _results;
        })();
        res = [];
        while (copy[0]) {
          if (copy[0].indent === level) {
            current = copy.shift();
            res.push(current);
          } else if (copy[0].indent > level) {
            nested = [];
            while (copy[0] && copy[0].indent > level) {
              nested.push(copy.shift());
            }
            current.children = transform(nested, level + 1);
          } else {
            return;
          }
        }
        return res;
      };
      return function(lines) {
        return transform(lines, 0);
      };
    }
  ]);

  services.factory('openTags', function() {
    var fn;

    fn = function(line) {
      var expected, openTags, token, _i, _len;

      openTags = [];
      for (_i = 0, _len = line.length; _i < _len; _i++) {
        token = line[_i];
        if (token.type === 'tag') {
          if (!token.close) {
            openTags.push(token.tag);
          } else {
            expected = _(openTags).last();
            if (expected === token.tag) {
              openTags.pop();
            } else {
              throw new fn.UnmatchedTagError(expected, token.tag);
            }
          }
        }
      }
      return openTags;
    };
    fn.UnmatchedTagError = (function() {
      function UnmatchedTagError(expected, found) {
        this.expected = expected;
        this.found = found;
      }

      UnmatchedTagError.prototype.toString = function() {
        return "Found " + this.found + " but was expecting " + this.expected;
      };

      return UnmatchedTagError;

    })();
    return fn;
  });

  services.factory('processLines', [
    'openTags', function(openTags) {
      return function(lines) {
        var line, _i, _len;

        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          line.openTags = openTags(line);
        }
        return lines;
      };
    }
  ]);

  services.factory('render', function() {
    var closeTag, indent, renderLine, renderLines;

    indent = function(indentLevel) {
      var numSpaces;

      numSpaces = indentLevel * 2;
      return _.str.repeat(" ", numSpaces);
    };
    closeTag = function(tagName) {
      return "</" + tagName + ">";
    };
    renderLine = function(line) {
      var closingTags, html;

      html = _(line).pluck('contents').join('');
      if (line.children) {
        html += '\n';
        html += renderLines(line.children);
      }
      closingTags = _(line.openTags).chain().reverse().map(closeTag).value().join('');
      if (line.children && closingTags !== '') {
        html += '\n' + indent(line.indent);
      }
      html += closingTags;
      return html;
    };
    renderLines = function(lines) {
      var html, line, _i, _len;

      html = "";
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        html += indent(line.indent);
        html += renderLine(line);
        if (line !== _.last(lines)) {
          html += '\n';
        }
      }
      return html;
    };
    return function(arg) {
      var line, lines;

      if (arg[0].contents) {
        line = arg;
        return renderLine(line);
      } else {
        lines = arg;
        return renderLines(lines);
      }
    };
  });

  services.factory('halfsies', [
    'parseTags', 'insertNewlines', 'processTags', 'groupByLines', 'processLines', 'indentLine', 'groupByIndent', 'render', function(parseTags, insertNewlines, processTags, groupByLines, processLines, indentLine, groupByIndent, render) {
      return function(text) {
        var html, lines, tokens, topLines;

        tokens = parseTags(text);
        tokens = insertNewlines(tokens);
        tokens = processTags(tokens);
        lines = groupByLines(tokens);
        lines = processLines(lines);
        lines = _(lines).map(indentLine);
        topLines = groupByIndent(lines);
        return html = render(topLines);
      };
    }
  ]);

}).call(this);
